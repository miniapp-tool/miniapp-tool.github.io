const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/guide/\":{\"title\":\"MP Tool\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"轻量的小程序增强框架。\",\" @mptool/mock: wx API 的简单模拟 \",\" @mptool/file: 一套简单的文件与存储 API \",\" @mptool/eval: 为小程序添加 eval \",\" @mptool/enhance: 一套完整的通信框架 \",\"打通任意页面和组件之间的通信\",\"额外的生命周期，支持页面间互相调用进行预加载处理\",\"组件与页面之间的相互引用\",\"支持热更新页面逻辑 (TODO)\"]}]},\"/guide/enhance.html\":{\"title\":\"@mptool/enhance\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"提示\",\"小程序增强框架，大小仅 7.56kB，同时提供完整的 TS 支持。\",\"目前支持跨组件、页面通信，页面组件间引用和生命周期扩展\",\"后续将支持 JS 解析与热更新。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"你需要使用 @mptool/enhance 导出的 $App，$Component 和 $Page 进行应用、页面与组件注册。\"]},{\"header\":\"$Config\",\"slug\":\"config\",\"contents\":[\"用于配置小程序框架，请在 app.js 中于 $App 之前调用。\"]},{\"header\":\"路由配置\",\"slug\":\"路由配置\",\"contents\":[\"由于小程序 JS 端没有读取 app.json 中配置路由的能力，小程序页面被推入页面栈前，小程序 JS 端也无法读取当前页面的路径，所以你需要配置小程序路由才可以让框架正常的工作。\",\"我们提供了 defaultRoute 和 routes 两个选项来帮助你传递页面路由。\",\"此外，框架引入了以下两个名词:\",\"页面简称\",\"为了能够很方便的表示其他页面，你需要为每个页面配置一个页面简称。\",\"页面简称应该是一个符合页面的单词或短语，不应包含 / 或空格\",\"路径模式\",\"你可以使用路径模式来表达小程序页面简称与实际路径的对应关系。\",\"你需要填写一个小程序路径表达式，并将页面名称出现的位置用 $name 替换。\",\"比如当你给出 /pages/$name/$name 时，框架会将 main 页面简称会对应到 /pages/main/main 路径，同时将 /pages/user/user 路径的页面简称解析为 user。\",\"你需要在 defaultRoute 填入一个页面模式，它表示在 routes 缺失或无法解析的情况下，对页面简称和页面路径的对应关系。换而言之，这是一个默认回退的选项。\",\"当你具有特别简单的小程序结构并可以完全用 defaultRoute 表示时，你无需配置 routes 选项。但是当你具有复杂的小程序结构 (如分包) 时你可以通过两种方式配置 routes 选项:\",\"你可以直接以对象形式表示简称到路径的映射。如:\",\"{ main: '/pages/main/main', cart: '/pages/cart/cart', user: '/pages/user/user', } \",\"你也可以在页面复杂的情况下数组格式表示小程序路径映射，数组的元素有两种填写方式:\",\"[页面简称, 小程序路经]\",\"[页面简称数组, 小程序路径模式]\",\"如:\",\"[ [[\\\"main\\\", \\\"cart\\\", \\\"user\\\"], \\\"/pages/$name/$name\\\"], [[\\\"search\\\", \\\"details\\\", \\\"order\\\"], \\\"/shop/$name/$name\\\"], [\\\"about\\\", \\\"/others/about/about\\\"], ]; \",\"等效于:\",\"{ 'main': '/pages/main/main', 'cart': '/pages/cart/cart', 'user': '/pages/user/user', 'search': '/shop/search/search', 'details': '/shop/details/details', 'order': '/shop/order/order', 'about': '/others/about/about', } \",\"请注意无法解析的路径会回退到 defaultRoute。\"]},{\"header\":\"跳转配置\",\"slug\":\"跳转配置\",\"contents\":[\"由于框架的 onNavigate 生命周期会造成跳转延时，你可以通过 maxDelay 控制框架延迟跳转的最大时长，单位为 ms，默认为 200。\",\"同时为了防止快速跳转触发额外生命周期导致的一些潜在问题 (诸如影响首屏渲染)，默认情况下，你只能在当前页面 onReady 生命周期触发之后再经过 100ms，才能通过框架进行下一次跳转。使用 onReady + 延时 是为了保证首屏渲染完成，避免同步的 onNavigate 周期阻塞小程序渲染。如果你需要一个更大或者更小的延迟值，请通过 minInterval 设置。\"]},{\"header\":\"构造器扩展\",\"slug\":\"构造器扩展\",\"contents\":[\"你可以通过以下扩展方法为每个组件和页面注入实例方法或属性。\",\"extendComponent(componentOptions) 用于扩展组件\",\"extendPage(pageOptions) 用于扩展页面\",\"injectComponent(componentOptions) 用于为组件注入，在框架扩展之后执行，这意味着你可以覆盖框架注入的方法。\",\"injectPage(pageOptions) 用于为页面注入，在框架扩展之后执行，这意味着你可以覆盖框架注入的方法。\"]},{\"header\":\"$App\",\"slug\":\"app\",\"contents\":[\"框架提供的应用注册器\"]},{\"header\":\"生命周期扩展\",\"slug\":\"生命周期扩展\",\"contents\":[\"我们提供了额外的 onAwake 生命周期。\",\"onAwake(time: number): 在小程序从后台唤醒时调用\",\"参数 time 为本次切入后台的时间，单位 ms\"]},{\"header\":\"属性扩展\",\"slug\":\"属性扩展\",\"contents\":[\"$all: Emitter 实例属性\"]},{\"header\":\"方法扩展\",\"slug\":\"方法扩展\",\"contents\":[\"$on, $off, $emit, $emitAsync: Emitter 实例方法\"]},{\"header\":\"组件和页面通用的跳转方法\",\"slug\":\"组件和页面通用的跳转方法\",\"contents\":[\"我们提供了新的 onNavigate 生命周期，想要触发它，你必须使用下列 API 进行跳转。\",\"注意\",\"由于相对 url 的写法会和页面简称出现混淆，框架不支持相对路径跳转，请一律使用页面简称或绝对路径\",\"我们在逻辑层包装了四个方法:\",\"$go(pagename: string): Promise<WechatMiniprogram.NavigateToSuccessCallbackResult>: 导航到指定页面，是 wx.navigateTo 的封装\",\"$redirect(pagename: string): Promise<WechatMiniprogram.GeneralCallbackResult>: 重定向到指定页面, 即替换页面，不产生历史，是 wx.redirectTo 的封装\",\"$switch(pagename: string): Promise<WechatMiniprogram.GeneralCallbackResult>: 跳转到指定 tabBar 页面，并关闭其他所有非 tabBar 页面，是 wx.switchTab 的封装\",\"$reLaunch(pagename: string): Promise<WechatMiniprogram.GeneralCallbackResult>: 关闭所有页面，之后打开到应用内的某个页面，是 wx.reLaunch 的封装\",\"在上述四个方法中，pagename 为页面简称，同时可以带上 queryString。\",\"你也可以传入一个带有可选参数使用绝对路径的 url。\",\"示例\",\"this.$go(\\\"play?vid=xxx&cid=xxx\\\"); this.$redirect(\\\"about?year=2021\\\"); this.$switch(\\\"main?user=mrhope\\\"); this.$launch(\\\"main?user=mrhope\\\"); \",\"注意\",\"请注意由于 wx.switchTab 不支持参数，参数将只用于触发 onNavigate\",\"此外，我们还在视图层一侧提供了四个代理方法 $bindGo, $bindRedirect, $bindSwitch 和$bindRelaunch\",\"你需要使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径\",\"data-before 跳转前执行\",\"data-after 跳转后执行\",\"例子\",\"<button bindtap=\\\"$bindRedirect\\\" data-url=\\\"/pages/play\\\" data-after=\\\"onClickAfter\\\" > click redirect </button> \",\"<button bindtap=\\\"$bindReLaunch\\\" data-url=\\\"play\\\" data-before=\\\"onClickBefore\\\"> click reLaunch </button> \",\"我们还提供了 $back(delta = 1) ，是 wx.navigateBack 的简单封装，delta 为返回的层数，默认为1\"]},{\"header\":\"$Page\",\"slug\":\"page\",\"contents\":[\"框架提供的页面注册器，结构为 $Page(name, options)。\",\"第一个参数为页面简称，第二个参数为页面选项。\",\"如:\"]},{\"header\":\"生命周期扩展\",\"slug\":\"生命周期扩展-1\",\"contents\":[\"onRegister(): 在页面即将注册时调用\",\"注意\",\"此时 this 上尚未挂载小程序原生方法\",\"onAppLaunch(options: WechatMiniprogram.App.LaunchShowOption): 在 App.onLaunch 触发时调用\",\"参数 options 为 App 启动时的 onLaunch 参数\",\"onAwake(time: number): 在小程序从后台唤醒时调用\",\"参数 time 为本次休眠时间，单位 ms\",\"onPreload(options: PageQuery): 预加载\",\"参数 options 为 url 参数对象\",\"可在其他页面中使用 this.$preload(pageNameWithArgs|pageUrl) 触发特定页面的预加载周期。\",\"你可以在用户特定行为后根据用户行为漏斗特点预加载对应界面准备数据。\",\"例子:\",\"小程序分包\",\"由于小程序每个分包下页面会在首次请求跳转到某个分包页面时注册，所以此时进入的首个页面无法触发 onPreload 周期。\",\"onNavigate(options: PageQuery): 页面即将被跳转时触发\",\"为触发 onNavigate 生命周期，跳转必须使用框架包装的方法\",\"参数 options 为 url 参数对象\",\"使用包装方法进行跳转时吗，会先执行对应页面的 onNavigate 再进行跳转。\",\"注意\",\"由于同步或异步的 onNavigate 均受到支持，为了避免执行时间较长的方法阻塞跳转、迷惑用户，在达到 maxDelay 时长后框架会强制进行跳转，而不再等待 onNavigate 完成。\",\"另外由于小程序每个分包下页面会在首次请求跳转到某个分包页面时注册，所以此时进入的首个页面无法触发 onNavigate 周期。\",\"建议将低耗时 (< 150ms) 的操作放入 onNavigate 周期，并在 onLoad 时判断 onNavigate 是否成功触发。\",\"例子:\"]},{\"header\":\"属性扩展\",\"slug\":\"属性扩展-1\",\"contents\":[\"$name: 当前页面名称\",\"$state: 框架生成的页面状态\",\"提示\",\"你可以考虑将部分自定义扩展的数据注入到此处\",\"$state.firstOpen: 是否是第一个打开的页面\",\"$refs: 指定了 ref 的子组件实例映射\",\"示例:\",\"<custom-component1 binding=\\\"$\\\" ref=\\\"customComp1\\\" /> <custom-component2 binding=\\\"$\\\" ref=\\\"customComp2\\\" /> \",\"$Page({ onLoad() { this.$refs.customComp1; // custom-component1 子组件的实例引用 this.$refs.customComp2; // custom-component2 子组件的实例引用 }, }); \",\"$all: Emitter 实例属性\"]},{\"header\":\"方法扩展\",\"slug\":\"方法扩展-1\",\"contents\":[\"$preload(pagename: string): 提前预加载指定页面，即触发对应页面的 onPreload 生命周期\",\"pagename 为页面简称，可以带上 queryString，也可填入带有可选参数的小程序绝对路径\",\"$currentPage(): PageInstance: 获取当前页面实例\",\"$getName(url: string): string: 获取传入页面地址的页面简称\",\"$getPath(name: string): string: 获取传入页面简称的页面路径\",\"$on, $off, $emit, $emitAsync: Emitter 实例方法\",\"$: 父子组件沟通器\",\"用于通过 binding=\\\"$\\\" 形式建立父子组件/页面与组件沟通\",\"提示\",\"我们这里做了一个优雅的 hack，实际上 binding 可以理解为 bind:ing，即框架向所有组件注入了 ing 事件并在内部调用它。\"]},{\"header\":\"$Component\",\"slug\":\"component\",\"contents\":[\"框架提供的组件注册器。\"]},{\"header\":\"属性扩展\",\"slug\":\"属性扩展-2\",\"contents\":[\"$id: 数字，当前组件的唯一标识\",\"$refID: 字符串，当前组件上用于索引的 ref ID 值\",\"$root: 当前组件所属的页面实例\",\"注意\",\"只在 attached, ready 生命周期后生效\",\"$parent: 当前组件所属的父组件或父页面实例\",\"注意\",\"只在 attached, ready 生命周期后生效\",\"$refs: 指定了 ref 的子组件实例 Map，在父组件获取子组件引用\",\"示例:\",\"<custom-component binding=\\\"$\\\" ref=\\\"customRef1\\\" /> \",\"$Component({ lifetimes: { attached() { this.$refs.customComp; // 根据ref属性获取子组件的实例引用 }, }, }); \",\"$all: Emitter 实例属性\"]},{\"header\":\"实例方法\",\"slug\":\"实例方法\",\"contents\":[\"$call(method: string, ...args: unknown[]): void: 通过消息的方式调用父组件方法，即使父组件方法不存在也不会报错\",\"参数 method 为需要调用的方法名称\",\"参数 args 为需要传递的参数\",\"$on, $off, $emit, $emitAsync: Emitter 实例方法\",\"$: 父子组件沟通器\",\"用于通过 binding=\\\"$\\\" 形式建立父子组件/页面与组件沟通\",\"提示\",\"我们这里做了一个优雅的 hack，实际上 binding 可以理解为 bind:ing，即框架向所有组件注入了 ing 事件并在内部调用它。\"]},{\"header\":\"Emitter\",\"slug\":\"emitter\",\"contents\":[\"Emitter 是一个很常规的发布订阅器。\",\"我们在 mitt 之上提供了新的 emitAsync 方法加入了对 async 函数的支持，可以异步的触发所有的监听器之后触发自身的回调。\"]},{\"header\":\"使用案例\",\"slug\":\"使用案例\",\"contents\":[\"import { Emitter } from \\\"@mptool/enhance\\\"; const emitter = Emitter(); // listen to an event emitter.on(\\\"foo\\\", (e) => console.log(\\\"foo\\\", e)); // listen to an event emitter.on( \\\"bar\\\", (e) => new Promise((resolve) => setTimeout(() => { console.log(\\\"bar\\\", e); resolve(); }, 200) ) ); // listen to all events emitter.on(\\\"*\\\", (type, e) => console.log(type, e)); // fire an event emitter.emit(\\\"foo\\\", { a: \\\"b\\\" }); // fire an event asynchronously emitter.emitAsync(\\\"bar\\\", { data: \\\"content\\\" }).then(() => { // now all handlers are complete }); // clearing all events emitter.all.clear(); // working with handler references: function onFoo() {} emitter.on(\\\"foo\\\", onFoo); // listen emitter.off(\\\"foo\\\", onFoo); // unlisten \",\"具体详情请见 API 文档\"]}]},\"/guide/file.html\":{\"title\":\"@mptool/file\",\"contents\":[{\"header\":\"文件 API\",\"slug\":\"文件-api\",\"contents\":[\"提示\",\"请注意，框架会自动帮你添加 USER_DATA_PATH 作为前缀，因此你无需关注它。\"]},{\"header\":\"工具类\",\"slug\":\"工具类\",\"contents\":[\"dirname(path)\",\"返回路径的文件夹部分\",\"exists(path)\",\"返回布尔值，代表文件或文件夹是否存在\",\"isDir(path)\",\"返回布尔值，代表路径是否是文件夹\",\"isFile(path)\",\"返回布尔值，代表路径是否是文件\"]},{\"header\":\"读取类\",\"slug\":\"读取类\",\"contents\":[\"ls(path)\",\"以数组形式列出目录下所有内容\",\"readFile(path, encoding)\",\"读取指定路径的文件内容并返回。当文件不存在时，返回 undefined。\",\"encoding 为文件的编码格式，可选，当文件为文本文件时默认 \\\"utf-8\\\"，为二进制文件时默认为 'buffer'\",\"readJSON(path, encoding)\",\"读取可序列化文件数据并返回解析结果。\",\"当 JSON 文件不存在或解析失败时，返回 undefined\",\"path: 读取的文件路径，不应含有 .json 后缀\",\"encoding: 文件的编码格式，可选，默认 utf-8\"]},{\"header\":\"操作类\",\"slug\":\"操作类\",\"contents\":[\"mkdir(path, recursive)\",\"创建目录。第二个参数 recursive可选，代表是否递归父目录。\",\"rm(path, type): void\",\"删除指定路径。\",\"第二个参数 type 是可选的，可填入 \\\"dir\\\" 或 \\\"file\\\"，填入可提升删除性能\",\"writeFile(path, data, encoding)\",\"写入文件\",\"path: 待写入的文件路径，若文件或其父文件夹不存在会自动创建\",\"data: 待写入的数据，可接受任意可序列化的数据或 Buffer\",\"encoding: 文件编码选项，可选，默认 utf-8 (数据) 或 binary (Buffer)\",\"writeJSON(path, data, encoding)\",\"写入可序列化数据为 JSON\",\"path: 写入文件的路径，若父文件夹不存在会自动创建\",\"data: 写入文件的数据，可接受任意可序列化的数据\",\"encoding: 文件编码选项，默认 utf-8\",\"saveFile(tempFilePath, path)\",\"将缓存文件保存到本地文件存储。\",\"tempFilePath: 缓存文件路径\",\"path: 保存文件路径\",\"saveOnlineFile(onlinePath, localPath): Promise<void>\",\"将在线文件保存到本地指定位置\",\"onlinePath: 在线文件路径\",\"localPath: 本地文件路径\",\"提示\",\"你无需关注本地保存路径是否已经存在。\",\"unzip(zipFilePath, targetPath): Promise<void>\",\"解压文件\",\"zipFilePath: 待解压的压缩文件路径\",\"targetPath: 解压到的目录\",\"提示\",\"你无需关注解压目录是否已经存在。\"]},{\"header\":\"存储 API\",\"slug\":\"存储-api\",\"contents\":[]},{\"header\":\"存取\",\"slug\":\"存取\",\"contents\":[\"put 和 take 可以存入任何数据，但存入的数据只能取出一次，且仅在当次小程序启动中有效。\",\"提示\",\"为了保证性能，以及由于小程序对 Function 进行了特殊处理，我们不会对存入的数据进行深拷贝。\",\"put<T = unknown>(key, data): 存数据。\",\"take<T = unknown>(key): 取数据\",\"提示\",\"当数据已经被取过一次后，后续返回 undefined。\"]},{\"header\":\"可持久化数据\",\"slug\":\"可持久化数据\",\"contents\":[\"get 和 set 设置的数据可持久化，且可以设置过期时间。\",\"注意\",\"请注意由于微信小程序底层上的问题，自动清除只发生在下一次读取并发现已经失效时，如果你没有后续读取对应的存储，它们会一直保存 (即使已经过期)。\",\"所以如果你使用了大量临时的键值去存入数据，你可能需要定期通过 check 手动检查并清除过期数据。\",\"set(key, value, expire)\",\"同步设置数据。\",\"key: 设置的键名\",\"value: 存入的值\",\"expire: 过期时间，可选，默认为 'once'\",\"'once': 默认，表示仅本次启动有效\",\"'keep': 表示保持上一次有效时间\",\"数字: 已毫秒为单位的有效时间\",\"提示\",\"请注意，如果传入 'keep' 时，存储中不存在同名键值，则该值也不会被写入。\",\"setAync(key, value, expire)\",\"set 的异步版本，在设置大量数据时可考虑使用，返回一个 Promise。\",\"get(key)\",\"同步读取数据并返回。\",\"当数据已经过期时，返回 undefined。\",\"key: 设置的键名\",\"getAync(key)\",\"get 的异步版本，在读取大量数据避免阻塞线程时可考虑使用，返回一个 Promise。\",\"key: 设置的键名\",\"remove(key)\",\"同步删除数据。\",\"key: 删除的键名\",\"removeAsync(key)\",\"异步删除数据，返回一个 Promise。\",\"key: 删除的键名\",\"check()\",\"同步检查并清理过期数据。\",\"checkAsync()\",\"异步检查并清理过期数据，返回一个 Promise。\"]}]},\"/api/enhance/\":{\"title\":\"@mptool/enhance\",\"contents\":[{\"header\":\"目录\",\"slug\":\"目录\",\"contents\":[\"$Config\",\"$App\",\"$Page\",\"$Component\",\"Emitter\",\"other utils (TODO)\"]}]},\"/api/enhance/app.html\":{\"title\":\"$App\",\"contents\":[{\"header\":\"配置\",\"slug\":\"配置\",\"contents\":[]},{\"header\":\"onAwake\",\"slug\":\"onawake\",\"contents\":[\"类型:\",\"function onAwake(time: number): void | Promise<void>; \",\"参数:\",\"time: 本次切入后台的时间，单位 ms\",\"在小程序从后台唤醒时调用\"]},{\"header\":\"注入\",\"slug\":\"注入\",\"contents\":[]},{\"header\":\"事件派发\",\"slug\":\"事件派发\",\"contents\":[\"事件派发相关，均为 $Emitter 实例属性或方法\",\"$on(type:string, handler: (event?:any) => void | Promise<void>): void: 监听 type 事件\",\"$emit(type:string, event?:any): void: 同步触发 type 事件\",\"$emitAsync(type:string, event?:any): Promise<void>: 异步触发 type 事件并接受回调\",\"$off(type:string, handler: (event?:any) => void | Promise<void>): Promise<void>: 取消监听 type 的 handler 事件或全部事件 (当未传入 handler)\",\"$all: 事件名称到已注册处理函数的映射\"]}]},\"/api/enhance/component.html\":{\"title\":\"$Component\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"类型: $Component(options: ComponentOPtions): string\",\"框架提供的组件注册器。\"]},{\"header\":\"注入\",\"slug\":\"注入\",\"contents\":[]},{\"header\":\"$id\",\"slug\":\"id\",\"contents\":[\"类型: number\",\"当前组件的唯一标识\"]},{\"header\":\"$refID\",\"slug\":\"refid\",\"contents\":[\"类型: string\",\"当前组件上用于索引的 ref ID 值\"]},{\"header\":\"$root\",\"slug\":\"root\",\"contents\":[\"类型: PageInstance\",\"当前组件所属的页面实例\",\"注意\",\"只在 attached, ready 生命周期后生效\"]},{\"header\":\"$parent\",\"slug\":\"parent\",\"contents\":[\"类型: PageInstance | ComponentInstance\",\"当前组件所属的父组件或父页面实例\",\"注意\",\"只在 attached, ready 生命周期后生效\"]},{\"header\":\"$refs\",\"slug\":\"refs\",\"contents\":[\"类型: Record<string, ComponentInstance>\",\"指定了 ref 的子组件实例 Map，可用于获取子组件引用\",\"示例\",\"<custom-component binding=\\\"$\\\" ref=\\\"customRef1\\\" /> \",\"$Component({ lifetimes: { attached() { this.$refs.customComp; // 根据 ref 属性获取子组件的实例引用 }, }, }); \"]},{\"header\":\"$call\",\"slug\":\"call\",\"contents\":[\"类型:\",\"function $call(method: string, ...args: unknown[]): void; \",\"参数:\",\"method: 需要调用的方法名称\",\"args: 为需要传递的参数\",\"通过消息的方式调用父组件方法，即使父组件方法不存在也不会报错\"]},{\"header\":\"事件派发\",\"slug\":\"事件派发\",\"contents\":[\"事件派发相关，均为 $Emitter 实例属性或方法\",\"$on(type:string, handler: (event?:any) => void | Promise<void>): void: 监听 type 事件\",\"$emit(type:string, event?:any): void: 同步触发 type 事件\",\"$emitAsync(type:string, event?:any): Promise<void>: 异步触发 type 事件并接受回调\",\"$off(type:string, handler: (event?:any) => void | Promise<void>): Promise<void>: 取消监听 type 的 handler 事件或全部事件 (当未传入 handler)\",\"$all: 事件名称到已注册处理函数的映射\"]},{\"header\":\"$\",\"slug\":\"\",\"contents\":[\"父子组件沟通器\",\"提供了通过 binding=\\\"$\\\" 形式建立父子组件/页面与组件沟通的能力\"]},{\"header\":\"$preload\",\"slug\":\"preload\",\"contents\":[\"类型:\",\"function $preload(pagename: string): void | Promise<void>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"提前预加载指定页面，即触发对应页面的 onPreload 生命周期\"]},{\"header\":\"$go\",\"slug\":\"go\",\"contents\":[\"类型:\",\"function $go( pagename: string ): Promise<WechatMiniprogram.NavigateToSuccessCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"导航到指定页面\",\"本函数是 wx.navigateTo 的封装\",\"示例\",\"this.$go(\\\"play?vid=xxx&cid=xxx\\\"); \"]},{\"header\":\"$redirect\",\"slug\":\"redirect\",\"contents\":[\"类型:\",\"function $redirect( pagename: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"重定向到指定页面, 即替换页面，不产生历史。\",\"本函数是 wx.redirectTo 的封装\",\"示例\",\"this.$redirect(\\\"about?year=2021\\\"); \"]},{\"header\":\"$switch\",\"slug\":\"switch\",\"contents\":[\"类型:\",\"function $switch( pagename: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"跳转到指定 tabBar 页面，并关闭其他所有非 tabBar 页面\",\"本函数是 wx.switchTab 的封装\",\"注意\",\"路径参数只用于触发 onNavigate (wx.switchTab 不支持参数)\",\"示例\",\"this.$switch(\\\"main?user=mrhope\\\"); \"]},{\"header\":\"$reLaunch\",\"slug\":\"relaunch\",\"contents\":[\"类型:\",\"function $reLaunch( pagename: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"关闭所有页面，之后打开到应用内的某个页面\",\"本函数是 wx.reLaunch 的封装\",\"示例\",\"this.$launch(\\\"main?user=mrhope\\\"); \"]},{\"header\":\"$back\",\"slug\":\"back\",\"contents\":[\"类型:\",\"function $back(delta = 1): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"delta: 后退的层级数，默认为 1\",\"本函数是 wx.navigateBack 的简单封装\"]},{\"header\":\"$bindGo\",\"slug\":\"bindgo\",\"contents\":[\"$go 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"data-before 跳转前执行\",\"data-after 跳转后执行\",\"提示\",\"<button bindtap=\\\"$bindGo\\\" data-url=\\\"play\\\" data-before=\\\"onClickBefore\\\"> click go </button> \"]},{\"header\":\"$bindRedirect\",\"slug\":\"bindredirect\",\"contents\":[\"$redirect 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"data-before 跳转前执行\",\"data-after 跳转后执行\",\"提示\",\"<button bindtap=\\\"$bindRedirect\\\" data-url=\\\"/pages/play\\\" data-after=\\\"onClickAfter\\\" > click redirect </button> \"]},{\"header\":\"$bindSwitch\",\"slug\":\"bindswitch\",\"contents\":[\"$switch 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"注意\",\"由于 wx.switchTab() 不支持参数，参数仅用于触发对应页面的 onNavigate 生命周期\",\"data-before 跳转前执行\",\"data-after 跳转后执行\"]},{\"header\":\"$bindRelaunch\",\"slug\":\"bindrelaunch\",\"contents\":[\"$reLaunch 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"data-before 跳转前执行\",\"data-after 跳转后执行\"]}]},\"/api/enhance/config.html\":{\"title\":\"$Config\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"全局配置器，必须放置在应用主脚本中在 $App 前调用。\"]},{\"header\":\"defaultRoute\",\"slug\":\"defaultroute\",\"contents\":[\"类型: string\",\"必填: 是\",\"默认路径模式。\",\"当你给出的页面路径或简称无法通过 routeMap 解析时，会回退到此路径\",\"填入小程序路径模式，小程序路径模式是一个路径字符串，用 $name 表示小程序简称的位置\",\"提示\",\"你可以填入 /pages/$name/$name 来表达:\",\"main': '/pages/main/main\",\"user': '/pages/user/user\"]},{\"header\":\"routes\",\"slug\":\"routes\",\"contents\":[\"类型: Record<string, string> | Array<[string, string] | [string[], string]>\",\"必填: 否\",\"小程序页面简称与路径映射。\",\"你可以直接以对象形式表示简称到路径的映射。如:\",\"{ main: '/pages/main/main', cart: '/pages/cart/cart', user: '/pages/user/user', } \",\"也支持以在页面复杂的情况下数组格式表示小程序路径映射，数组的元素有两种填写方式:\",\"[页面简称, 小程序路经]\",\"[页面简称数组, 小程序路经模式]\",\"小程序路径模式是一个路径字符串，用 $name 表示小程序简称的位置\",\"如:\",\"[ [[\\\"main\\\", \\\"cart\\\", \\\"user\\\"], \\\"/pages/$name/$name\\\"], [[\\\"search\\\", \\\"details\\\", \\\"order\\\"], \\\"/shop/$name/$name\\\"], [\\\"about\\\", \\\"/others/about/about\\\"], ]; \",\"等效于:\",\"{ 'main': '/pages/main/main', 'cart': '/pages/cart/cart', 'user': '/pages/user/user', 'search': '/shop/search/search', 'details': '/shop/details/details', 'order': '/shop/order/order', 'about': '/others/about/about', } \",\"提示\",\"无法解析的路径会回退到 defaultRoute\"]},{\"header\":\"maxDelay\",\"slug\":\"maxdelay\",\"contents\":[\"类型: number\",\"默认: 200\",\"跳转延迟执行的最长时间，单位 ms\"]},{\"header\":\"minInterval\",\"slug\":\"mininterval\",\"contents\":[\"类型: number\",\"默认: 100\",\"允许进行跳转据页面首屏渲染后的最小间隔时间，单位 ms\"]},{\"header\":\"extendComponent\",\"slug\":\"extendcomponent\",\"contents\":[\"类型: (options: TrivalComponentOptions): void\",\"参数:\",\"options: 组件选项\",\"必填: 否\",\"自定义扩展组件\",\"时机在框架执行扩展之前，可为每个组件挂载实例方法\"]},{\"header\":\"injectComponent\",\"slug\":\"injectcomponent\",\"contents\":[\"类型: (options: TrivalComponentOptions): void\",\"参数:\",\"options: 组件选项\",\"必填: 否\",\"自定义扩展组件\",\"时机在框架执行扩展之后，这意味着你可以覆盖框架的方法\"]},{\"header\":\"extendPage\",\"slug\":\"extendpage\",\"contents\":[\"类型: (name: string, options: TrivalPageOptions): void\",\"参数:\",\"name: 页面名称\",\"options: 页面选项\",\"必填: 否\",\"自定义扩展页面，在框架执行扩展之前\"]},{\"header\":\"injectPage\",\"slug\":\"injectpage\",\"contents\":[\"类型: (name: string, options: TrivalPageOptions): void\",\"参数:\",\"name: 页面名称\",\"options: 页面选项\",\"必填: 否\",\"自定义注入页面\",\"在框架执行扩展之后，这意味着你可以覆盖框架的方法\"]}]},\"/api/enhance/emitter.html\":{\"title\":\"Emitter\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"类型:\",\"function Emitter<Events extends Record<EventType, unknown>>( all?: EventHandlerMap<Events> ): EmitterInstance<Events>; \",\"框架中使用的事件派发器。\"]},{\"header\":\"创建实例\",\"slug\":\"创建实例\",\"contents\":[\"你需要通过调用 Emitter() 返回一个 Emitter 实例。\",\"提示\",\"Emitter 支持在调用时通过泛型传入一个 Events 对象来在 TypeScript 下进行类型推导。\",\"例子\",\"import { Emitter } from \\\"@mptool/enhance\\\"; type Events = { foo: string; bar?: number; baz: void; }; const emitter = Emitter<Events>(); // inferred as EmitterInstance<Events> emitter.on(\\\"foo\\\", (e) => {}); // 'e' has inferred type 'string' emitter.emit(\\\"foo\\\", 42); // Error: Argument of type 'number' is not assignable to parameter of type 'string'. (2345) emitter.on(\\\"baz\\\"); // 'baz' should not contain event object \"]},{\"header\":\"emitterInstance.all\",\"slug\":\"emitterinstance-all\",\"contents\":[\"类型: all: EventHandlerMap<Events>\",\"事件名称到已注册处理函数的映射。\"]},{\"header\":\"emitterInstance.on\",\"slug\":\"emitterinstance-on\",\"contents\":[\"为给定类型注册事件处理程序。\",\"类型:\",\"function on<Key extends keyof Events>( type: Key, handler: GenericEventHandler ): void; \",\"参数:\",\"type: string | symbol 要侦听的事件类型，或使用 '*' 监听所有事件\",\"handler: Function 响应给定事件时调用的函数\"]},{\"header\":\"emitterInstance.off\",\"slug\":\"emitterinstance-off\",\"contents\":[\"移除给定类型的事件处理程序。如果未传入 handler，则删除给定类型的所有处理程序。\",\"类型:\",\"function off<Key extends keyof Events>( type: Key, handler?: GenericEventHandler ): void; \",\"参数:\",\"type: string | symbol 要取消监听事件类型，或使用 '*' 取消所有事件\",\"handler: Function 要删除的处理程序函数\"]},{\"header\":\"emitterInstance.emit\",\"slug\":\"emitterinstance-emit\",\"contents\":[\"调用给定类型的所有处理函数。如果存在 '*'，则会在所有处理函数调用结束后调用它。\",\"注意\",\"不支持手动触发 *\",\"类型:\",\"function emit<Key extends keyof Events>(type: Key, event?: Events[Key]): void; \",\"参数:\",\"type: string | symbol 要取消监听事件类型，或使用 '*' 取消所有事件\",\"event: 任何值，推荐传入对象\"]},{\"header\":\"emitterInstance.emitAsync\",\"slug\":\"emitterinstance-emitasync\",\"contents\":[\"异步调用给定类型的所有处理函数。如果存在 '*'，则会在所有处理函数调用结束后调用它。\",\"全部处理函数调用完成后，触发自身回调\",\"注意\",\"不支持手动触发 *\",\"类型:\",\"function emitAsync<Key extends keyof Events>( type: Key, event?: Events[Key] ): Promise<void>; \",\"参数:\",\"type: string | symbol 要取消监听事件类型，或使用 '*' 取消所有事件\",\"event: 任何值，推荐传入对象\"]}]},\"/api/enhance/page.html\":{\"title\":\"$Page\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"类型:\",\"function $Page< Data extends Record<string, any>, Custom extends Record<string, any> >(name: string, options: PageOptions<Data, Custom>): void; \",\"参数:\",\"name: 页面简称\",\"options: 页面选项\",\"框架提供的页面注册器\"]},{\"header\":\"扩展\",\"slug\":\"扩展\",\"contents\":[]},{\"header\":\"onRegister\",\"slug\":\"onregister\",\"contents\":[\"类型: (): void\",\"在页面即将注册时调用\",\"注意\",\"此时 this 上尚未挂载小程序原生方法\"]},{\"header\":\"onAppLaunch\",\"slug\":\"onapplaunch\",\"contents\":[\"类型: onAppLaunch(options: WechatMiniprogram.App.LaunchShowOption): void | Promise<void>\",\"参数:\",\"options: App 启动时的 onLaunch 参数\",\"在 App.onLaunch 触发时调用\",\"注意\",\"框架在 App 启动时仅触发此方法，不会检测与等待异步方法返回。\"]},{\"header\":\"onAwake\",\"slug\":\"onawake\",\"contents\":[\"类型: onAwake(time: number): void | Promise<void>\",\"参数:\",\"time: 为本次休眠时间，单位 ms\",\"在小程序从后台唤醒时调用\",\"注意\",\"框架在 App 启动时仅触发此方法，不会检测与等待异步方法返回。\"]},{\"header\":\"onPreload\",\"slug\":\"onpreload\",\"contents\":[\"类型: onPreload(options: PageQuery): void | Promise<void>\",\"参数:\",\"options: 为通过触发预加载携带参数生成的参数对象\",\"预加载生命周期，可在其他页面中使用 this.$preload(pageNameWithArgs | pageUrlWIthArgs) 触发特定页面的预加载周期。\",\"你可以在用户特定行为后根据用户行为漏斗特点预加载对应界面准备数据。\",\"小程序分包\",\"由于小程序每个分包下页面会在首次请求跳转到某个分包页面时注册，所以此时进入的首个页面无法触发 onPreload 周期。\"]},{\"header\":\"onNavigate\",\"slug\":\"onnavigate\",\"contents\":[\"类型: onNavigate(options: PageQuery): void | Promise<void>\",\"参数:\",\"options: 为通过触发预加载携带参数生成的参数对象\",\"页面即将被跳转时触发。\",\"在进行页面间跳转时吗，会先执行对应页面的 onNavigate 再进行跳转。\",\"建议将低耗时 (< 150ms) 的操作放入 onNavigate 周期，并在 onLoad 时判断 onNavigate 是否成功触发。\",\"提示\",\"为触发 onNavigate 生命周期，跳转必须使用框架包装的方法:\",\"$go\",\"$redirect\",\"$switch\",\"$reLaunch\",\"$bindGo\",\"$bindRedirect\",\"$bindSwitch\",\"$bindReLaunch\",\"注意\",\"由于同步或异步的 onNavigate 均受到支持，为了避免执行时间较长的方法阻塞跳转、迷惑用户，在达到 maxDelay 时长后框架会强制进行跳转，而不再等待 onNavigate 完成。\",\"另外由于小程序每个分包下页面会在首次请求跳转到某个分包页面时注册，所以此时进入的首个页面无法触发 onNavigate 周期。\"]},{\"header\":\"注入\",\"slug\":\"注入\",\"contents\":[]},{\"header\":\"$name\",\"slug\":\"name\",\"contents\":[\"类型: string\",\"当前页面名称\"]},{\"header\":\"$state\",\"slug\":\"state\",\"contents\":[\"类型: Record<string, any>\",\"框架生成的页面状态\",\"提示\",\"你可以考虑将部分自定义扩展的数据注入到此处\",\"$state.firstOpen: 是否是第一个打开的页面\"]},{\"header\":\"事件派发\",\"slug\":\"事件派发\",\"contents\":[\"事件派发相关，均为 $Emitter 实例属性或方法\",\"$on(type:string, handler: (event?:any) => void | Promise<void>): void: 监听 type 事件\",\"$emit(type:string, event?:any): void: 同步触发 type 事件\",\"$emitAsync(type:string, event?:any): Promise<void>: 异步触发 type 事件并接受回调\",\"$off(type:string, handler: (event?:any) => void | Promise<void>): Promise<void>: 取消监听 type 的 handler 事件或全部事件 (当未传入 handler)\"]},{\"header\":\"$refs\",\"slug\":\"refs\",\"contents\":[\"类型: Record<string, ComponentInstance>\",\"指定了 ref 的子组件实例 Map，可用于获取子组件引用\",\"示例\",\"<custom-component binding=\\\"$\\\" ref=\\\"customRef1\\\" /> \",\"$Component({ lifetimes: { attached() { this.$refs.customComp; // 根据 ref 属性获取子组件的实例引用 }, }, }); \"]},{\"header\":\"$\",\"slug\":\"\",\"contents\":[\"父子组件沟通器\",\"提供了通过 binding=\\\"$\\\" 形式建立父子组件/页面与组件沟通的能力\"]},{\"header\":\"$preload\",\"slug\":\"preload\",\"contents\":[\"类型:\",\"function $preload(pagename: string): void | Promise<void>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"提前预加载指定页面，即触发对应页面的 onPreload 生命周期\"]},{\"header\":\"$go\",\"slug\":\"go\",\"contents\":[\"类型:\",\"function $go( pagename: string ): Promise<WechatMiniprogram.NavigateToSuccessCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"导航到指定页面\",\"本函数是 wx.navigateTo 的封装\",\"示例\",\"this.$go(\\\"play?vid=xxx&cid=xxx\\\"); \"]},{\"header\":\"$redirect\",\"slug\":\"redirect\",\"contents\":[\"类型:\",\"function $redirect( pagename: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"重定向到指定页面, 即替换页面，不产生历史。\",\"本函数是 wx.redirectTo 的封装\",\"示例\",\"this.$redirect(\\\"about?year=2021\\\"); \"]},{\"header\":\"$switch\",\"slug\":\"switch\",\"contents\":[\"类型:\",\"function $switch( pagename: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"跳转到指定 tabBar 页面，并关闭其他所有非 tabBar 页面\",\"本函数是 wx.switchTab 的封装\",\"注意\",\"路径参数只用于触发 onNavigate (wx.switchTab 不支持参数)\",\"示例\",\"this.$switch(\\\"main?user=mrhope\\\"); \"]},{\"header\":\"$reLaunch\",\"slug\":\"relaunch\",\"contents\":[\"类型:\",\"function $reLaunch( pagename: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"pagename: 页面简称，可以带上 queryString\",\"关闭所有页面，之后打开到应用内的某个页面\",\"本函数是 wx.reLaunch 的封装\",\"示例\",\"this.$launch(\\\"main?user=mrhope\\\"); \"]},{\"header\":\"$back\",\"slug\":\"back\",\"contents\":[\"类型:\",\"function $back(delta = 1): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"delta: 后退的层级数，默认为 1\",\"本函数是 wx.navigateBack 的简单封装\"]},{\"header\":\"$bindGo\",\"slug\":\"bindgo\",\"contents\":[\"$go 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"data-before 跳转前执行\",\"data-after 跳转后执行\",\"提示\",\"<button bindtap=\\\"$bindGo\\\" data-url=\\\"play\\\" data-before=\\\"onClickBefore\\\"> click go </button> \"]},{\"header\":\"$bindRedirect\",\"slug\":\"bindredirect\",\"contents\":[\"$redirect 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"data-before 跳转前执行\",\"data-after 跳转后执行\",\"提示\",\"<button bindtap=\\\"$bindRedirect\\\" data-url=\\\"/pages/play\\\" data-after=\\\"onClickAfter\\\" > click redirect </button> \"]},{\"header\":\"$bindSwitch\",\"slug\":\"bindswitch\",\"contents\":[\"$switch 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"注意\",\"由于 wx.switchTab() 不支持参数，参数仅用于触发对应页面的 onNavigate 生命周期\",\"data-before 跳转前执行\",\"data-after 跳转后执行\"]},{\"header\":\"$bindRelaunch\",\"slug\":\"bindrelaunch\",\"contents\":[\"$reLaunch 的视图层代理方法，你需要在视图层使用 data-set 来绑定跳转配置:\",\"data-url 跳转到的页面简称或绝对路径，可带参数\",\"data-before 跳转前执行\",\"data-after 跳转后执行\"]}]},\"/api/file/\":{\"title\":\"@mptool/file\",\"contents\":[{\"header\":\"目录\",\"slug\":\"目录\",\"contents\":[\"文件类\",\"缓存类\"]}]},\"/api/file/file.html\":{\"title\":\"文件 API\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"提示\",\"请注意，框架会自动帮你添加 USER_DATA_PATH 作为前缀，因此你无需关注它。\"]},{\"header\":\"dirname\",\"slug\":\"dirname\",\"contents\":[\"类型:\",\"function dirname(path: string): string; \",\"参数:\",\"path: 传入的路径\",\"获得路径的文件夹部分\"]},{\"header\":\"exists\",\"slug\":\"exists\",\"contents\":[\"类型:\",\"function exists(path: string): boolean; \",\"参数:\",\"path: 传入的路径\",\"判断文件或文件夹是否存在\"]},{\"header\":\"isDir\",\"slug\":\"isdir\",\"contents\":[\"类型:\",\"function isDir(path: string): boolean; \",\"参数:\",\"path: 传入的路径\",\"判断路径是否是文件夹\"]},{\"header\":\"isFile\",\"slug\":\"isfile\",\"contents\":[\"类型:\",\"function isFile(path: string): boolean; \",\"参数:\",\"path: 传入的路径\",\"判断路径是否是文件\"]},{\"header\":\"ls\",\"slug\":\"ls\",\"contents\":[\"类型:\",\"function ls(path: string): string[]; \",\"参数:\",\"path: 传入的路径\",\"列出目录下内容\"]},{\"header\":\"readFile\",\"slug\":\"readfile\",\"contents\":[\"类型:\",\"function readFile<T = unknown>( path: string, encoding = \\\"utf-8\\\" ): T | undefined; \",\"参数:\",\"path: 所读取文件的路径\",\"encoding: 文件的编码格式，默认 utf-8\",\"返回值:\",\"当文件不存在时，返回 undefined\",\"读取文件内容\"]},{\"header\":\"readJSON\",\"slug\":\"readjson\",\"contents\":[\"类型:\",\"function readJSON<T = unknown>( path: string, encoding = \\\"utf-8\\\" ): T | undefined; \",\"参数:\",\"path: 所读取文件的路径，实际读取会自动添加 .json 后缀名\",\"encoding: 文件的编码格式，默认 utf-8\",\"返回值:\",\"当 JSON 文件不存在或解析失败时，返回 undefined\",\"读取 JSON 文件内容并解析。\"]},{\"header\":\"mkdir\",\"slug\":\"mkdir\",\"contents\":[\"类型:\",\"function mkdir(path: string, recursive = true): void; \",\"参数:\",\"path: 待创建的文件夹\",\"recursive: 是否递归创建可能不存在的父目录\",\"创建目录\"]},{\"header\":\"rm\",\"slug\":\"rm\",\"contents\":[\"类型:\",\"function rm(path: string, type?: \\\"dir\\\" | \\\"file\\\"): void; \",\"参数:\",\"path: 待删除内容的路径\",\"type: 所删除内容的类型，可选，传入明确的 type 可提升性能\",\"删除文件或文件夹\"]},{\"header\":\"writeFile\",\"slug\":\"writefile\",\"contents\":[\"类型:\",\"function writeFile(path: string, data: T, encoding = \\\"utf-8\\\"): void; \",\"参数:\",\"path: 待写入的文件路径，若文件或其父文件夹不存在会自动创建\",\"data: 写入文件的数据，可接受任意可序列化的数据或\",\"encoding: 文件编码选项，默认 utf-8 (数据) 或 binary (Buffer)\",\"向指定文件写入内容\"]},{\"header\":\"writeJSON\",\"slug\":\"writejson\",\"contents\":[\"类型:\",\"function writeJSON(path: string, data: T, encoding = \\\"utf-8\\\"): void; \",\"参数:\",\"path: 带写入文件的路径，若文件和父文件夹不存在会自动创建，实际写入会自动添加 .json 后缀名\",\"data: 写入文件的数据，可接受任意可序列化的数据\",\"encoding: 文件编码选项，默认 utf-8 (数据)\",\"向指定文件写入可序列化数据\"]},{\"header\":\"saveFile\",\"slug\":\"savefile\",\"contents\":[\"类型:\",\"function saveFile(tempFilePath: string, path: string): void; \",\"参数:\",\"tempFilePath: 缓存文件路径\",\"path: 保存文件路径\",\"将缓存文件保存到本地文件存储。\"]},{\"header\":\"saveOnlineFile\",\"slug\":\"saveonlinefile\",\"contents\":[\"类型:\",\"function saveOnlineFile( onlinePath: string, targetPath: string ): Promise<void>; \",\"参数:\",\"onlinePath: 在线文件路径\",\"targetPath: 目标文件路径\",\"返回值:\",\"当保存失败时，err 为文字格式的失败消息或数字格式的非 200 状态码\",\"将在线文件保存到本地指定位置 (会自动创建本地保存文件夹与文件)。\"]},{\"header\":\"unzip\",\"slug\":\"unzip\",\"contents\":[\"类型:\",\"function unzip(zipFilePath: string, targetPath: string): Promise<void>; \",\"参数:\",\"zipFilePath: 待解压的压缩文件路径\",\"targetPath: 解压到的目录 (你无需关注它是否已经存在)\",\"返回值:\",\"当解压失败时，err 为文字格式的失败消息\",\"将缓存文件保存到本地文件存储。\"]}]},\"/api/file/storage.html\":{\"title\":\"存储 API\",\"contents\":[{\"header\":\"非持久化数据\",\"slug\":\"非持久化数据\",\"contents\":[\"存入的数据只能取出一次，且仅在当次小程序启动中有效\"]},{\"header\":\"put\",\"slug\":\"put\",\"contents\":[\"类型:\",\"function put<T = unknown>(key: string, data: unknown): void; \",\"参数:\",\"key: 存入的键值\",\"data: 存入的数据，可为任意值。\",\"存数据。该数据只能取出一次，且仅在当次小程序启动中有效。\"]},{\"header\":\"take\",\"slug\":\"take\",\"contents\":[\"类型:\",\"function take<T = unknown>(key: string): T; \",\"参数:\",\"path: 传入的路径\",\"取出在本次小程序启动后设置的数据。\",\"当数据已经被取过一次后，后续返回 undefined。\"]},{\"header\":\"可持久化数据\",\"slug\":\"可持久化数据\",\"contents\":[\"get 和 set 设置的数据可持久化，且可以设置过期时间。\",\"注意\",\"请注意由于微信小程序底层上的问题，自动清除只发生在下一次读取并发现已经失效时，如果你没有后续读取对应的存储，它们会一直保存 (即使已经过期)。\",\"所以如果你使用了大量临时的键值去存入数据，你可能需要定期通过 check 手动检查并清除过期数据。\"]},{\"header\":\"set\",\"slug\":\"set\",\"contents\":[\"类型:\",\"function set<T = unknown>( key: string, value: T, expire: number | \\\"keep\\\" | \\\"once\\\" = \\\"once\\\" ): void; \",\"参数:\",\"key: 设置的键名\",\"value: 存入的值\",\"expire: 过期时间\",\"'once': 仅本次启动有效\",\"'keep': 表示保持上一次缓存时间\",\"数字: 代表过期时间，单位为毫秒\",\"提示\",\"请注意，如果传入 'keep' 时，存储中不存在同名键值，则该值也不会被写入。\",\"存储数据。\"]},{\"header\":\"setAync\",\"slug\":\"setaync\",\"contents\":[\"类型:\",\"function setAync<T = unknown>( key: string, value: T, expire: number | \\\"keep\\\" | \\\"once\\\" ): Promise<WechatMiniprogram.GeneralCallbackResult | void>; \",\"set 的异步版本，在设置大量数据时可考虑使用。\"]},{\"header\":\"get\",\"slug\":\"get\",\"contents\":[\"类型:\",\"function get<T = unknown>(key: string): T; \",\"参数:\",\"key: 设置的键名\",\"读取数据。\",\"当数据已经过期或不存在时，返回 undefined。\"]},{\"header\":\"getAync\",\"slug\":\"getaync\",\"contents\":[\"类型:\",\"function getAync<T = unknown>(key: string): Promise<T | undefined>; \",\"参数:\",\"key: 设置的键名\",\"get 的异步版本，在读取大量数据避免阻塞线程时可考虑使用。\"]},{\"header\":\"remove\",\"slug\":\"remove\",\"contents\":[\"类型:\",\"function remove(key: string): void; \",\"参数:\",\"key: 删除的键名\",\"删除某个键名对应的数据。\"]},{\"header\":\"removeAsync\",\"slug\":\"removeasync\",\"contents\":[\"类型:\",\"function removeAsync( key: string ): Promise<WechatMiniprogram.GeneralCallbackResult>; \",\"参数:\",\"key: 删除的键名\",\"remove 的异步版本，在删除大量数据避免阻塞线程时可考虑使用。\"]},{\"header\":\"check\",\"slug\":\"check\",\"contents\":[\"类型:\",\"function check(): void; \",\"参数:\",\"key: 删除的键名\",\"检查所有数据暂存，并清理已过期数据。\"]},{\"header\":\"checkAsync\",\"slug\":\"checkasync\",\"contents\":[\"类型:\",\"function checkAsync(): Promise<void[]>; \",\"参数:\",\"key: 删除的键名\",\"check 的异步版本\"]}]},\"/api/\":{\"title\":\"Api\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
